\section{Anhang}

\section*{Resultate}

\subsection*{Daten aus der SUS Umfrage}

\input{surveydatatable.tex}

\subsection*{Erzeugung der Umfragegraphen}

\begin{python}
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.ticker import AutoMinorLocator
from matplotlib.font_manager import FontProperties

plt.style.use('fivethirtyeight')

def subplot(data):
    bins=[1,2,3,4,5]
    y = [data.value_counts()[x] if x in data.value_counts() else 0 for x in bins]

    f, (ax_box, ax_hist) = plt.subplots(2, sharex=True, gridspec_kw={"height_ratios": (.1, .86)})
    f.set_figwidth(20)
    f.set_figheight(2.3)

    whisker = sns.boxplot(data.values,
                          ax=ax_box,showmeans=True,
                          meanline=True, color="white",
                          meanprops=dict(color='darkgrey', linestyle='-', linewidth=2.5,))
    ax_hist.bar(bins, y, color="darkgrey")
    ax_box.set(yticks=[])

    sns.despine(ax=ax_hist)
    sns.despine(ax=ax_box, left=False)

    f.suptitle(data.name, fontsize=16)

    left, width = -.06, 1
    bottom, height = -0.09, .33
    right = left + width
    top = bottom + height
    p = patches.Rectangle(
        (left, bottom), width, height,
        fill=False, transform=ax_hist.transAxes, clip_on=False
    )

    font = FontProperties()
    font.set_weight('bold')
    font.set_size(18)
    bbox = dict(facecolor='whitesmoke', edgecolor='grey', pad=0.2, boxstyle='round')
    ax_hist.text(right, height, 'sehr',
        horizontalalignment='center',
        verticalalignment='top',
        transform=ax.transAxes,
        fontproperties=font,
        color = 'dimgray',
        backgroundcolor='whitesmoke',
        bbox=bbox)
    ax_hist.text(left, height, 'gar nicht',
        horizontalalignment='center',
        verticalalignment='top',
        transform=ax.transAxes,
        fontproperties=font,
        color = 'dimgray',
        backgroundcolor='whitesmoke',
        bbox=bbox)

    plt.yticks(np.arange(0, 9+1, 3.0))
    ax_hist.set_ylim([0,9])
    ax_hist.minorticks_on()
    ax_hist.xaxis.grid(False)
    ax_hist.yaxis.grid(b=False, which='minor', color='lightgray', linestyle='-')
    ax_hist.yaxis.set_minor_locator(AutoMinorLocator(3))
    ax_hist.yaxis.grid(b=True, which='major', color='darkgray', linestyle='-', markersize=1)
    ax_box.xaxis.grid(True)

for col in df:
    subplot(df[col])
\end{python}

\subsection*{Erzeugen des Anforderungsgraphen}


\begin{python}
import networkx as nx
from networkx.drawing.nx_agraph import write_dot, graphviz_layout
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
import matplotlib.patches as mpatches
import matplotlib.patches
from matplotlib import pylab
URL_DOC =   "https://docs.google.com/spreadsheets/d/e/2PACX-1vQfFMHK_XVtNXex5pAPh6boF4qdBH0iB6_ndGWV"\
            "-FANyBXh1TB9MuIQ_Ex7gBlcrGOMO2Tn133NxVf1/pub?gid=0&single=true&output=csv"

color_map = {
  'kann': 'tomato',
  'soll': 'orange',
  'muss': 'green'
}

anforderungen = pd.read_csv(URL_DOC)

unpack = lambda cell: [c[1:-1] for c in cell.split("|")]

anforderungen_ = [row['Titel'] for i, row in anforderungen.iterrows()]
nachbedingungen_ = [unpack(row['Nachbedingungen']) for i, row in anforderungen.iterrows()]
vorbedingungen_ =  ["" if pd.isnull(row['Vorbedingungen']) else unpack(row['Vorbedingungen']) for i, row in anforderungen.iterrows()]

flat_nachbedingungen = [item for sublist in nachbedingungen_ for item in sublist]
flat_vorbedingungen = [item for sublist in nachbedingungen_ for item in sublist]


G = nx.DiGraph()
G.add_nodes_from(anforderungen_)
G.add_nodes_from(flat_nachbedingungen)

A = G.subgraph(anforderungen_)
N = G.subgraph(flat_nachbedingungen)

for i, a in enumerate(anforderungen_):
    for n in nachbedingungen_[i]:
        G.add_edge(n,a, weight=1000)
    for v in vorbedingungen_[i]:
        G.add_edge(a,v, weight=0.0001)

G = G.reverse()
A = A.reverse()
n = N.reverse()

pos=graphviz_layout(G, prog='dot')

plt.figure(3,figsize=(36,40))
plt.axis('off')

color = [color_map[row['Prioritaet']] for i, row in anforderungen.iterrows()]

nx.draw_networkx_nodes(A, pos, node_shape='s', node_size=10000, node_color=color, alpha=0.6, label=True)
nx.draw_networkx_nodes(N, pos, node_shape='o', node_size=200, node_color='grey')
nx.draw_networkx_edges(G, pos, node_shape='o')

x_centr = np.average([p[0] for p in pos.values()])

fontsize = 10

def shift_x(x):
    align_map = {
        -1: 'left',
        1: 'right'
    }
    s = 1 if x < x_centr else -1
    return (align_map[s], x - (s*7))

def shift_y(y):
    return (y + 20)

def position_string(node):
    x,y = pos[node]
    align, x = shift_x(x) if False in N else ('center', x)
    y = y-10 if  node in N else y
    y = shift_y(y) if node in A else y
    return (align,x,y)

for n in G:
    align,x,y = position_string(n)

    plt.text(x,y,s=n, bbox=dict(facecolor='lightgray', alpha=0.5),
             horizontalalignment=align,
             color='black', fontsize=27)
plt.rcParams["legend.fontsize"] = 22
plt.legend(handles=[
    mpatches.Patch(color=color_map['muss'], label='Prioritaet: muss'),
    mpatches.Patch(color=color_map['kann'], label='Prioritaet: kann'),
    mpatches.Patch(color=color_map['soll'], label='Prioritaet: soll'),
    mpatches.Ellipse((1,1), 4, 0, fill=True, label='Nachbedingung', color='grey')
])
plt.show()
\end{python}


\pagebreak
\printglossaries
