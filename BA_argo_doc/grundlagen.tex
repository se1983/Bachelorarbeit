\section{Grundlagen}
 
\subsection{Objekt-Relationale Unverträglichkeit}

In einem Softwareparadigma manifestiert sich ein bestimmtes Konzept in der Modellierung der Welt. Durch diese konzeptionelle Betrachtungsweise beeinflusst ein Paradigma den Erstellungsprozess sowie die Ergebnisse des Softwaredesigns und zwingt diesem seine Grenzen auf. Probleme bei der Kombination verschiedener Paradigmen werden dabei als Unverträglichkeit (impedance Missmatch) bezeichnet.
Objektorientierte Programmierung  und eine relationale Abfrage von Datensätzen sind weit verbreitete Paradigmen in der Softwareentwicklung. Damit ist die objekt-relationale Unverträglichkeit (object-relational impedance mismatch) eine häufig auftretende Herausforderung. (vgl. \cite{ireland2009classification} S. 36-38)\\

\cite{ireland2009classification} nennt dabei unter anderem folgende Betrachtungsweisen als Ursachen für die objektrelationale Unverträglichkeit.

\begin{description}
 \item [Strukturelle Unterschiede]  
 Die objektorientierte Programmierung erlaubt das definieren, beliebig komplexer Strukturen aus Methoden und Klassen. Durch Vererbungsstrukturen ist es möglich, Objekte zu spezialisieren und Konzepte für die Erstellung der Klassen zu generalisieren. Spricht man von einer relationalen Algebra, diese wird durch Tupeln, Mengen und Wahrheitswerten definiert. Inhärent wiederholbare Strukturen oder Hierarchien können mit diesen Mitteln nicht umgesetzt werden.   
 
 \item [Datenkapselung] 
 In der objektorientierten Programmierung können die intrinsischen Attribute eines Objektes verborgen werden. Dieses Konzept sit als Kapselung bekannt und erlaubt es den Zugriff auf die gekapselten Strukturen einzuschränken. In einer relationalen Algebra ist eine derartige Abstraktion über die Daten nicht vorgesehen.
 
 
 \item [Objektidentität]  
 Durch die Instanziierung eines Objektes aus einer Klasse erhält dieses eine eindeutige Identität, somit unterscheiden sich zwei Objekte auch wenn diese träger eines identischen Datensatzes sind, durch ihre Repräsentation im Arbeitsspeicher. Relationen werden durch den Primärschlüssel, und damit über ihre Daten, definiert. Zwei eigenständige Relationen mit identischem Datensatz ist damit nicht möglich.
\end{description}


Als Hilfsmittel zur Überwindung der oben genannten Probleme werden Objekt-Realtionale Mapper (ORM bzw. O/R-Mapper) eingesetzt. Durch dieses Mapping wird eine Schnittstelle oder Abstraktionsebene zwischen Programmteilen aus den jeweiligen Sprachparadigmen definiert, um den impedance Mismatch möglichst transparent zu überwinden.



%% TODO: Vorstellung der in SQLALCHEMY verwendeten Entwurfsmuster zur Überwindung des impedance mismatch 

    

% BEGIN -- Geographische Informationssysteme
    \subsection{Geographische Informationssysteme  ODER }
% END

% BEGIN -- Software
    \subsection{Verwendete Software}
    \subsubsection{Network Common Data Format}
    
    Das Network Common Data Format (NetCDF) dient zum Austausch von wissenschaftlichen Daten. Es ist eine Weiterentwicklung des von der NASA entwickelten Common Data Format (CDF). Das Format zeichnet sich dadurch aus, dass es selbstbeschreibend ist. Dadurch wird die Dokumentation mit den Daten mitgeführt. Dies soll die Portabilität des Datensatzes verbessern.  \footnote{vgl. \cite{FisherNetCDF}}
   
    Neben einigen anderen Sprachen, wurde auch eine Bibliothek für Python entwickelt \footnote{Siehe \cite{netCDF4}} Mit dieser ist es möglich, die Binärdaten zu öffnen und zu numpy-Arrays zu extrahieren. In Listing \ref{lst:example_netcdf} ist die Verwendung exemplarisch an der Extraktion und Berechnung des Datensatzerstellungsdatum aufgezeigt und im Folgenden beschrieben.
    
    \pythonexternal[%
        % ---------------------------------------------
        %   PYTHON netCDF als Beispiel JULD
        caption = {Extraktion und Berechnung des Erstellungsdatums eines NetCDF-Datensatzes},%
        label = {lst:example_netcdf}]%
        {scr/beispiele/netCDF_juld.py}
    
    Um einen Datensatz zu öffnen, bildet man eine Instanz der Klasse \texttt{netCDF4.Dataset}. Die Auswahl des Profils gelingt durch die Pfadangabe als Parameter bei der Instanzierung.
    
    Über das Attribut \texttt{dataset.variables} werden die Datensätze als \texttt{OrderedDict} gehalten. Bei der Extraktion eines Parameters erhält man zunächst die Dokumentation des jeweiligen Datensatzes. In diesem Fall handelt es sich um den Zeitpunkt der Sattelitenübertragung des betreffenden Messprofils.
    
    Aus der Dokumentation lassen sich für die Weiterverarbeitung wichtige Parameter entnehmen.
    So ist der Datensatz in Form des C-Datentyps \texttt{float64} codiert. Beim Datumsformat handelt es sich um \textit{Julian day} ab dem Zeitpunkt \textit{01. Januar 1950}.
    
    Um die Werte eines Datensatzes zu extrahieren, wird über die numpy-slicing Operation \texttt{arr[::]} der Datensatz in vektorieller Form extrahiert. Da in diesem Array nur ein skalarer \texttt{float64} Wert enthalten ist, kann dieser als nulltes Element extrahiert werden.
    
    Zur Überführung in das Format des durch die ISO 8601 bei uns normierten Gregorianischen Kalenders wird ein Datumsobjekt des Referenzdatums benötigt. Durch die Verwendung von \texttt{timedelta} werden die Tage aus dem Feld \texttt{JULD} addiert. Da ein Messzyklus 10 Tage andauert, kann an dieser Stelle der Datensatz durch die Entferndung der Dezimalstellen vereinfacht werden. Die Casting-Operation \texttt{int()} rundet in jedem Fall ab.
    
% BEGIN NUMPY
    \subsubsection{numpy}
    
    Numpy ist eine Pythonbibliothek zur diskreten Verarbeitung von ein- oder mehrdimensionalen Arrays. 
    
    Nach der Extraktion der CDF-Daten, liegen diese als maskierte Arrays vor. Diese erlauben auch das fehlen einzelner Datensätze.
% END 

% BEGIN JULDATE
\subsubsection{Julian Date}
%END
        
% BEGIN FLASK
    \subsubsection{Flask}
    
    Flask wurde im Jahre (YXXX) von Armin Ronacher gegründet. 
    
    Die Idee startete Ursprünglich als Aprilscherz. \footnote{\cite{openingtheflask}} Der Designansatz wurde aber von vielen Menschen als positiv aufgefasst. Dieser wurde daraufhin unter dem Namen Flask released.
    
    \pythonexternal[%
    caption={Minimalbeispiel für die Verwendung von Flask},%
    label={lst:flaskHELLOWORLD}]{./scr/beispiele/flask_hello.py}
    
    Das Framework verfolgt den Ansatz "`\textit{Why things work the way they work}"'. Funktionalitäten werden also nicht versteckt, sondern sind dem Entwickler einfach zugänglich. Durch diese Designentscheidung ist es möglich ganze Webapplikationen mit nur wenigen Zeilen Code und in einer einzigen Sourcecode-Datei zu realisieren. Diese Transparenz wird durch ein global verfügbares "`magisches"' !sic Objekt ermöglicht. 
    Es lassen sich auch weitere Instanzen innerhalb einer Applikation erstellen. 
    Teile der Applikation können über Blueprints modularisiert werden.
    
   Durch die Templateengine \textbf{Jinja} erlaubt Flask das generalisieren von HTML-Dokumenten. Durch diese ist es möglich erweiterbare Grundtemplates anzulegen, Variablen abzufragen, zu überprüfen und über Kollektionen zu iterieren.
   

   
  Durch sogenannte \textbf{Blueprints} ist es möglich, eine logische Trennung zwischen Teilbereichen der Applikation vorzunehmen. Diese Modularisierung erlaubt die Definierung von spezifischen Datenordnern sowie für HTML-Templates als auch spezifischer subrouten der Module innerhalb der Applikation.
  
  (...)
  

  In der Grundausstatung der Funktionsumfang von Flask sehr beschränkt. Der KISS-Ansatz bedingt, dass benötigte Funktionalitäten nachgerüstet werden müssen. Im Folgenden wird auf einige in dieser Applikation sinnvolle Erweiterungen eingegangen:
  
  \begin{description}
   \item [flask\_sqlalchemy] erlaubt die transparente Anbindung des ORM in die Applikation. In der Grundausstatung besitzt Flask keine Funktionalität um Datenbanken aus der Webapplikation anzusprechen. Durch die Einbindung dieser Erweiterung erhält man ein Framework, das dem Entwurfmuster MVC entspricht.
   
   Entspürechend den in Flask gängigen Entwurfsmustern entspricht, wird die Anbdindung an den ORM durch ein globales Objekt modelliert. Dieses ist eine Instanz der Klasse \texttt{flask\_sqlalchemy.SQLAlchemy} und stellt die Operationen von SQLAlchemy zur verfügung.
   
   \item [flask\_script] rüstet den Funktionsumfang der Webapplikation um eine zentrale Steurungseinheit auf. Diese Erweiterung besitzt bereits vorgefertigte Steuerungsmodule. Darunter finden sich scripte  zum starten der Webapplikation oder zum starten eines Python-REPL mit den Umgebungsvariablen der Webapplikation. Unter Verwendung des Decorator Entwurfsmuster lässt sich das definierte Steuerungsmodul um beliebige Funktionalitäten erweitern.
   
  \end{description}

    
% END
 
    
    \subsubsection{JSON?}

% BEGIN OL3
    \subsubsection{openLayers}
    
    OpenLayers ist ein Framework zur Entwicklung webbasierter Geoapplikationen. Dieses ist in JavaScript entwickelt und erlaubt durch eine layerstruktur den Aufbau komplexer Kartenapplikationen. Dabei lassen sich die Elemente der Karten durch folgende Objekte strukturieren:
    
    \begin{description}
     \item [\texttt{ol.Map}]  
     \item [\texttt{ol.View}] 
     \item [\texttt{ol.Overlay}]
     \item [\texttt{ol.layer.Base}]
     \item [\texttt{ol.interaction.Interaction}]
     \item [\texttt{ol.control.Control}]
    \end{description}

    
    OpenLayers ist eine Programmbibliotek um interaktive Geoapplikationen zu entwickeln. Das Framework ist in Javascript entwickelt und nimmt alle benötigten Berechnungen auf Clientseite vor.
    
    Die Bibliothek erlaubt es Kartenmaterial aus verschiedensten Quellen zu Rendern. Dabei können Kachel- oder auch Vektorbasierte Materialien eingebunden werden.
    
    \begin{description}
     \item [Kachel-Layer]  liefern Bilddaten direkt aus. Dabei werden die Kartenmatherialien in Kacheln aufgeteilt.Dadurch das die Bilder in Teilbereiche untergliedert sind, müssen nur die Bildbereiche ausgeliefert werden, die für die Darstellung des Kartenausschnittes vonnöten sind.
     
     \item [Vektor-Layer] sind Beschreibungen von Linien und Polygonen. Die Darstellung wird nicht anhand von Bildmaterial generiert, sondern anhand von geometrischen Beschreibungen gezeichnet. 
    \end{description}
    
    Neben der reinen Darstellung erlaubt die Bibliothek auch die Definition von  "`\texttt{controls}"'. Dabei lassen sich Zoom-, Rotations- und Mouse-Positions-Effekte umsetzen. Siehe Quelle \cite{openlayersbeginnersguide} S. 296
    
    Zu zeichnende Daten lassen sich über GEOJson-Objekte modellieren. Die Bibliothek folgt einem objektorientierten Entwurfsmuster und erlaubt das transparente Hinzufügen und Ändern von Layern der Karte.
    
    

% END     
    \subsubsection{D3}
    
    \subsection{...}

% END
